<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flower of Life — Dynamic Art</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      cursor: crosshair;
    }
    #container {
      width: min(100vw, 100vh);
      aspect-ratio: 1 / 1;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>

<div id="container">
  <canvas id="c"></canvas>
</div>

<script>
// ============================================================
//  Flower of Life — Dynamic Art  (Canvas API版)
//  SVG + DOM操作の代わりにCanvas APIで毎フレーム直接描画。
//  feGaussianBlur の再計算がなくなり、フレームレートが安定する。
// ============================================================

const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');

// HiDPI 対応 (Retina等では 2倍、それ以上はキャップして負荷を抑える)
const DPR = Math.min(window.devicePixelRatio || 1, 2);
const L   = 600;  // 論理サイズ (描画座標系)

canvas.width  = L * DPR;
canvas.height = L * DPR;
ctx.scale(DPR, DPR);

const cx = L / 2, cy = L / 2;
const R      = 75;
const RINGS  = 2;
const CLIP_R = R * 3; // 225

// ── 六角形グリッド ──────────────────────────────────────────
function hexToPixel(q, s) {
  return { x: cx + R * (q + s * 0.5), y: cy + R * s * Math.sqrt(3) / 2 };
}
function hexDist(q, s) {
  return Math.max(Math.abs(q), Math.abs(q + s), Math.abs(s));
}
function buildHexGrid(rings) {
  const cells = [];
  for (let q = -rings; q <= rings; q++) {
    for (let s = -rings; s <= rings; s++) {
      if (hexDist(q, s) <= rings) {
        const p = hexToPixel(q, s);
        p.pixelDist = Math.hypot(p.x - cx, p.y - cy);
        cells.push(p);
      }
    }
  }
  return cells.sort((a, b) => a.pixelDist - b.pixelDist);
}
const cells = buildHexGrid(RINGS);

// ── 状態 ─────────────────────────────────────────────────────
let mouseX = cx, mouseY = cy, mouseNX = 0;
let rotAngle = 0, rotSpeed = 0.06;
let ripples  = [];
const startT = performance.now();

// ── 入力処理 ─────────────────────────────────────────────────
function getCoords(clientX, clientY) {
  const r = canvas.getBoundingClientRect();
  return {
    x: (clientX - r.left) * (L / r.width),
    y: (clientY - r.top)  * (L / r.height),
  };
}

canvas.addEventListener('mousemove', e => {
  ({ x: mouseX, y: mouseY } = getCoords(e.clientX, e.clientY));
  mouseNX = (mouseX - cx) / (L / 2);
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  ({ x: mouseX, y: mouseY } = getCoords(t.clientX, t.clientY));
  mouseNX = (mouseX - cx) / (L / 2);
}, { passive: false });

// 波紋を 3 重リングで生成
function spawnRipple(x, y, hue) {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => ripples.push({
      x, y,
      r:         4,
      opacity:   0.80 - i * 0.15,
      speed:     3.8  - i * 0.5,
      maxR:      CLIP_R * 1.65,
      hue:       (hue + i * 28) % 360,
      lineWidth: 2.0  - i * 0.45,
    }), i * 120);
  }
}

canvas.addEventListener('click', e => {
  const p = getCoords(e.clientX, e.clientY);
  spawnRipple(p.x, p.y, ((performance.now() / 1000) * 25) % 360);
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  const p = getCoords(touch.clientX, touch.clientY);
  spawnRipple(p.x, p.y, ((performance.now() / 1000) * 25) % 360);
}, { passive: false });

// 自動波紋
setTimeout(()  => spawnRipple(cx, cy, 60), 1800);
setInterval(() => spawnRipple(cx, cy, ((performance.now() / 1000) * 25) % 360), 4500);

// ── ユーティリティ ────────────────────────────────────────────
function hsl(h, s, l, a = 1) {
  return `hsla(${((h % 360) + 360) % 360},${s}%,${l}%,${a})`;
}

// 毎フレーム 1 回だけ生成し、全ペタルで共有する放射グラデーション
function buildGradient(hue) {
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, CLIP_R);
  g.addColorStop(0.00, hsl(hue,        100, 97));
  g.addColorStop(0.40, hsl(hue +  35,   95, 65));
  g.addColorStop(0.75, hsl(hue +  90,   88, 52));
  g.addColorStop(1.00, hsl(hue + 165,   78, 42));
  return g;
}

// ── メインループ ──────────────────────────────────────────────
function animate(ts) {
  const t   = (ts - startT) / 1000;   // 経過秒
  const hue = (t * 25) % 360;          // 色相サイクル

  // ----- 背景クリア -----
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, L, L);

  // ----- アンビエントグロー -----
  {
    const g = ctx.createRadialGradient(cx, cy, CLIP_R * 0.7, cx, cy, CLIP_R * 1.35);
    g.addColorStop(0, hsl(hue + 165, 78, 45, 0.10));
    g.addColorStop(1, hsl(hue + 165, 78, 45, 0.00));
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(cx, cy, CLIP_R * 1.35, 0, Math.PI * 2);
    ctx.fill();
  }

  // ----- 波紋 (花より前面に描くため別途) -----
  ripples.forEach(rp => {
    ctx.save();
    ctx.globalAlpha = rp.opacity;
    ctx.beginPath();
    ctx.arc(rp.x, rp.y, rp.r, 0, Math.PI * 2);
    ctx.strokeStyle = hsl(rp.hue, 90, 68);
    ctx.lineWidth   = rp.lineWidth;
    ctx.shadowColor = hsl(rp.hue, 90, 68);
    ctx.shadowBlur  = 14;
    ctx.stroke();
    ctx.restore();
  });
  // 波紋ステート更新 (DOM操作なし・配列のみ)
  ripples = ripples.filter(rp => {
    rp.r       += rp.speed;
    rp.opacity *= 0.971;
    return rp.opacity >= 0.01 && rp.r <= rp.maxR;
  });

  // ----- 回転量を更新 (マウスX で速度を±調整) -----
  const targetSpeed = 0.06 + mouseNX * 0.14;
  rotSpeed  += (targetSpeed - rotSpeed) * 0.04; // 一次ローパスで補間
  rotAngle  += rotSpeed;
  const rotRad = rotAngle * Math.PI / 180;

  // マウス座標を回転前の空間へ逆変換 → ペタルとの距離計算に使用
  const mdx = mouseX - cx, mdy = mouseY - cy;
  const rmx = cx + mdx * Math.cos(-rotRad) - mdy * Math.sin(-rotRad);
  const rmy = cy + mdx * Math.sin(-rotRad) + mdy * Math.cos(-rotRad);

  // ----- フラワー本体 -----
  // グラデーションは 1 回生成して全ペタルで共有
  const grad = buildGradient(hue);

  ctx.save();
  // 外縁を正円にクリップ (SVGの clipPath 相当)
  ctx.beginPath();
  ctx.arc(cx, cy, CLIP_R + 1, 0, Math.PI * 2);
  ctx.clip();

  // shadowBlur はループ外で一括設定してコンテキスト切り替えを最小化
  ctx.shadowBlur = 9;

  cells.forEach(cell => {
    // セル座標を回転
    const dx = cell.x - cx, dy = cell.y - cy;
    const rx = cx + dx * Math.cos(rotRad) - dy * Math.sin(rotRad);
    const ry = cy + dx * Math.sin(rotRad) + dy * Math.cos(rotRad);

    // フェードイン (中心から外へ時差で出現)
    const fi = Math.min(1, Math.max(0, (t - cell.pixelDist * 0.0042) / 0.8));
    if (fi <= 0) return;

    // 放射状進行波
    const wave = 0.68 + 0.32 * Math.sin(t * 1.9 - (cell.pixelDist / CLIP_R) * Math.PI * 1.6);

    // マウス近傍ハイライト (逆変換済み座標で計算)
    const mdist  = Math.hypot(cell.x - rmx, cell.y - rmy);
    const bright = 1 + Math.max(0, (R * 1.8 - mdist) / R) * 0.45;

    ctx.globalAlpha = Math.min(1, fi * wave * bright);
    ctx.lineWidth   = 1.2 + Math.max(0, (R * 1.5 - mdist) / R) * 1.8;
    ctx.shadowColor = hsl(hue + (cell.pixelDist / CLIP_R) * 110, 90, 65);
    ctx.strokeStyle = grad;

    ctx.beginPath();
    ctx.arc(rx, ry, R, 0, Math.PI * 2);
    ctx.stroke();
  });

  ctx.restore();

  // ----- 外縁装飾リング -----
  const outerFI    = Math.min(0.9, Math.max(0, (t - 1.5) / 0.9));
  const outerAlpha = outerFI * (0.82 + 0.18 * Math.sin(t * 1.4));
  if (outerAlpha > 0.01) {
    ctx.save();
    ctx.globalAlpha = outerAlpha;
    ctx.beginPath();
    ctx.arc(cx, cy, CLIP_R, 0, Math.PI * 2);
    ctx.strokeStyle = grad;
    ctx.lineWidth   = 1.6;
    ctx.shadowColor = hsl(hue + 165, 78, 50);
    ctx.shadowBlur  = 18;
    ctx.stroke();
    ctx.restore();
  }

  // ----- 中心輝点 -----
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, 3.5, 0, Math.PI * 2);
  ctx.fillStyle   = hsl(hue, 100, 95);
  ctx.shadowColor = hsl(hue, 100, 95);
  ctx.shadowBlur  = 12;
  ctx.fill();
  ctx.restore();

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>
</body>
</html>
